const validUrl=require("valid-url"),helpers=require("./helpers"),stateLib=require("@adobe/aio-lib-state"),fetch=require("node-fetch"),crypto=require("crypto"),loggerNamespace="@adobe/aio-lib-events",logger=require("@adobe/aio-lib-core-logging")(loggerNamespace,{level:process.env.LOG_LEVEL}),ADOBE_IOEVENTS_SECURITY_DOMAIN="https://static.adobeioevents.com";async function verifyDigitalSignature(e,r,t){const i=[e.digiSignature1,e.digiSignature2],o=ADOBE_IOEVENTS_SECURITY_DOMAIN+e.publicKeyPath1,c=ADOBE_IOEVENTS_SECURITY_DOMAIN+e.publicKeyPath2;if(validUrl.isHttpsUri(o)&&validUrl.isHttpsUri(c)){const e=await fetchPemEncodedPublicKeys(o,c);return await verifySignature(i,t,e,r)}return logger.error("either or both public key urls %s and %s are not valid",o,c),!1}async function fetchPemEncodedPublicKeys(e,r){let t,i;try{const o=await stateLib.init();t=await fetchPubKeyFromCacheOrApi(e,o),i=await fetchPubKeyFromCacheOrApi(r,o)}catch(e){return logger.error("error occurred while fetching pem encoded public keys either from cache or public key urls due to %s",e.message),helpers.exportFunctions.genErrorResponse(500,"Error occurred while fetching pem encoded Public Key")}return[t,i]}async function fetchPubKeyFromCacheOrApi(e,r){const t=await getPubKeyFileName(e),i=await getKeyFromCache(r,t);return i?i.toString():await fetchKeyFromApiAndPutInCache(e,r,t)}async function fetchKeyFromApiAndPutInCache(e,r,t){logger.info("public key %s not present in aio state lib cache, fetching directly from the url..",t);const i=await fetchPublicKeyFromCloudFront(e);return await r.put(t,i),i}async function getKeyFromCache(e,r){try{return(await e.get(r)).value}catch(e){logger.error("aio lib state get error due to => %s",e.message)}return null}async function getPubKeyFileName(e){return e.substring(e.lastIndexOf("/")+1)}async function fetchPublicKeyFromCloudFront(e){let r;return await fetch(e).then((e=>e.text())).then((t=>{logger.info("successfully fetched the public key %s from cloud front url %s",t,e),r=t})).catch((r=>(logger.error("error fetching the public key from cloud front url %s due to => %s",e,r.message),helpers.exportFunctions.genErrorResponse(500,r.message)))),r}async function verifySignature(e,r,t,i){let o,c;try{for(let i=0;i<e.length;i++)if(c=await createCryptoPublicKey(t[i]),o=await cryptoVerify(e[i],c,r),o)return o}catch(e){return logger.error("error occured while verifying digital signature for client id %s due to %s ",i,e.message),!1}}async function cryptoVerify(e,r,t){try{return crypto.verify("rsa-sha256",Buffer.from(t),r,Buffer.from(e,"base64"))}catch(e){return logger.error("error during crypto verification of digital signature due to => "+e.message),!1}}async function createCryptoPublicKey(e){return crypto.createPublicKey({key:e,format:"pem",type:"spki"})}function isTargetRecipient(e,r){const t=e.recipient_client_id;return null!=t?t===r:(logger.error("target recipient client id is either null or missing"),!1)}const exportFunctions={verifyDigitalSignature,isTargetRecipient,fetchPemEncodedPublicKeys,cryptoVerify,verifySignature,fetchPublicKeyFromCloudFront,fetchPubKeyFromCacheOrApi,getKeyFromCache};module.exports={exportFunctions};