function createBrowserLocalStorageCache(e){const t=`algoliasearch-client-js-${e.key}`;let r;const a=()=>(void 0===r&&(r=e.localStorage||window.localStorage),r),s=()=>JSON.parse(a().getItem(t)||"{}"),o=e=>{a().setItem(t,JSON.stringify(e))};return{get:(t,r,a={miss:()=>Promise.resolve()})=>Promise.resolve().then((()=>{(()=>{const t=e.timeToLive?1e3*e.timeToLive:null,r=s(),a=Object.fromEntries(Object.entries(r).filter((([,e])=>void 0!==e.timestamp)));if(o(a),!t)return;const n=Object.fromEntries(Object.entries(a).filter((([,e])=>{const r=(new Date).getTime();return!(e.timestamp+t<r)})));o(n)})();const r=JSON.stringify(t);return s()[r]})).then((e=>Promise.all([e?e.value:r(),void 0!==e]))).then((([e,t])=>Promise.all([e,t||a.miss(e)]))).then((([e])=>e)),set:(e,r)=>Promise.resolve().then((()=>{const o=s();return o[JSON.stringify(e)]={timestamp:(new Date).getTime(),value:r},a().setItem(t,JSON.stringify(o)),r})),delete:e=>Promise.resolve().then((()=>{const r=s();delete r[JSON.stringify(e)],a().setItem(t,JSON.stringify(r))})),clear:()=>Promise.resolve().then((()=>{a().removeItem(t)}))}}function createFallbackableCache(e){const t=[...e.caches],r=t.shift();return void 0===r?createNullCache():{get:(e,a,s={miss:()=>Promise.resolve()})=>r.get(e,a,s).catch((()=>createFallbackableCache({caches:t}).get(e,a,s))),set:(e,a)=>r.set(e,a).catch((()=>createFallbackableCache({caches:t}).set(e,a))),delete:e=>r.delete(e).catch((()=>createFallbackableCache({caches:t}).delete(e))),clear:()=>r.clear().catch((()=>createFallbackableCache({caches:t}).clear()))}}function createNullCache(){return{get:(e,t,r={miss:()=>Promise.resolve()})=>t().then((e=>Promise.all([e,r.miss(e)]))).then((([e])=>e)),set:(e,t)=>Promise.resolve(t),delete:e=>Promise.resolve(),clear:()=>Promise.resolve()}}function createInMemoryCache(e={serializable:!0}){let t={};return{get(r,a,s={miss:()=>Promise.resolve()}){const o=JSON.stringify(r);if(o in t)return Promise.resolve(e.serializable?JSON.parse(t[o]):t[o]);const n=a(),i=s&&s.miss||(()=>Promise.resolve());return n.then((e=>i(e))).then((()=>n))},set:(r,a)=>(t[JSON.stringify(r)]=e.serializable?JSON.stringify(a):a,Promise.resolve(a)),delete:e=>(delete t[JSON.stringify(e)],Promise.resolve()),clear:()=>(t={},Promise.resolve())}}function createAuth(e,t,r){const a={"x-algolia-api-key":r,"x-algolia-application-id":t};return{headers:()=>e===AuthMode.WithinHeaders?a:{},queryParameters:()=>e===AuthMode.WithinQueryParameters?a:{}}}function createRetryablePromise(e){let t=0;const r=()=>(t++,new Promise((a=>{setTimeout((()=>{a(e(r))}),Math.min(100*t,1e3))})));return e(r)}function createWaitablePromise(e,t=((e,t)=>Promise.resolve())){return Object.assign(e,{wait:r=>createWaitablePromise(e.then((e=>Promise.all([t(e,r),e]))).then((e=>e[1])))})}function shuffle(e){let t=e.length-1;for(;t>0;t--){const r=Math.floor(Math.random()*(t+1)),a=e[t];e[t]=e[r],e[r]=a}return e}function addMethods(e,t){return t?(Object.keys(t).forEach((r=>{e[r]=t[r](e)})),e):e}function encode(e,...t){let r=0;return e.replace(/%s/g,(()=>encodeURIComponent(t[r++])))}const version="4.18.0",AuthMode={WithinQueryParameters:0,WithinHeaders:1};function createMappedRequestOptions(e,t){const r=e||{},a=r.data||{};return Object.keys(r).forEach((e=>{-1===["timeout","headers","queryParameters","data","cacheable"].indexOf(e)&&(a[e]=r[e])})),{data:Object.entries(a).length>0?a:void 0,timeout:r.timeout||t,headers:r.headers||{},queryParameters:r.queryParameters||{},cacheable:r.cacheable}}const CallEnum={Read:1,Write:2,Any:3},HostStatusEnum={Up:1,Down:2,Timeouted:3},EXPIRATION_DELAY=12e4;function createStatefulHost(e,t=HostStatusEnum.Up){return{...e,status:t,lastUpdate:Date.now()}}function isStatefulHostUp(e){return e.status===HostStatusEnum.Up||Date.now()-e.lastUpdate>EXPIRATION_DELAY}function isStatefulHostTimeouted(e){return e.status===HostStatusEnum.Timeouted&&Date.now()-e.lastUpdate<=EXPIRATION_DELAY}function createStatelessHost(e){return"string"==typeof e?{protocol:"https",url:e,accept:CallEnum.Any}:{protocol:e.protocol||"https",url:e.url,accept:e.accept||CallEnum.Any}}const MethodEnum={Delete:"DELETE",Get:"GET",Post:"POST",Put:"PUT"};function createRetryableOptions(e,t){return Promise.all(t.map((t=>e.get(t,(()=>Promise.resolve(createStatefulHost(t))))))).then((e=>{const r=e.filter((e=>isStatefulHostUp(e))),a=e.filter((e=>isStatefulHostTimeouted(e))),s=[...r,...a];return{getTimeout:(e,t)=>(0===a.length&&0===e?1:a.length+3+e)*t,statelessHosts:s.length>0?s.map((e=>createStatelessHost(e))):t}}))}const isNetworkError=({isTimedOut:e,status:t})=>!e&&0==~~t,isRetryable=e=>{const t=e.status;return e.isTimedOut||isNetworkError(e)||2!=~~(t/100)&&4!=~~(t/100)},isSuccess=({status:e})=>2==~~(e/100),retryDecision=(e,t)=>isRetryable(e)?t.onRetry(e):isSuccess(e)?t.onSuccess(e):t.onFail(e);function retryableRequest(e,t,r,a){const s=[],o=serializeData(r,a),n=serializeHeaders(e,a),i=r.method,c=r.method!==MethodEnum.Get?{}:{...r.data,...a.data},d={"x-algolia-agent":e.userAgent.value,...e.queryParameters,...c,...a.queryParameters};let l=0;const u=(t,c)=>{const m=t.pop();if(void 0===m)throw createRetryError(stackTraceWithoutCredentials(s));const h={data:o,headers:n,method:i,url:serializeUrl(m,r.path,d),connectTimeout:c(l,e.timeouts.connect),responseTimeout:c(l,a.timeout)},p=e=>{const r={request:h,response:e,host:m,triesLeft:t.length};return s.push(r),r},y={onSuccess:e=>deserializeSuccess(e),onRetry(r){const a=p(r);return r.isTimedOut&&l++,Promise.all([e.logger.info("Retryable failure",stackFrameWithoutCredentials(a)),e.hostsCache.set(m,createStatefulHost(m,r.isTimedOut?HostStatusEnum.Timeouted:HostStatusEnum.Down))]).then((()=>u(t,c)))},onFail(e){throw p(e),deserializeFailure(e,stackTraceWithoutCredentials(s))}};return e.requester.send(h).then((e=>retryDecision(e,y)))};return createRetryableOptions(e.hostsCache,t).then((e=>u([...e.statelessHosts].reverse(),e.getTimeout)))}function createTransporter(e){const{hostsCache:t,logger:r,requester:a,requestsCache:s,responsesCache:o,timeouts:n,userAgent:i,hosts:c,queryParameters:d,headers:l}=e,u={hostsCache:t,logger:r,requester:a,requestsCache:s,responsesCache:o,timeouts:n,userAgent:i,headers:l,queryParameters:d,hosts:c.map((e=>createStatelessHost(e))),read(e,t){const r=createMappedRequestOptions(t,u.timeouts.read),a=()=>retryableRequest(u,u.hosts.filter((e=>0!=(e.accept&CallEnum.Read))),e,r);if(!0!==(void 0!==r.cacheable?r.cacheable:e.cacheable))return a();const s={request:e,mappedRequestOptions:r,transporter:{queryParameters:u.queryParameters,headers:u.headers}};return u.responsesCache.get(s,(()=>u.requestsCache.get(s,(()=>u.requestsCache.set(s,a()).then((e=>Promise.all([u.requestsCache.delete(s),e])),(e=>Promise.all([u.requestsCache.delete(s),Promise.reject(e)]))).then((([e,t])=>t))))),{miss:e=>u.responsesCache.set(s,e)})},write:(e,t)=>retryableRequest(u,u.hosts.filter((e=>0!=(e.accept&CallEnum.Write))),e,createMappedRequestOptions(t,u.timeouts.write))};return u}function createUserAgent(e){const t={value:`Algolia for JavaScript (${e})`,add(e){const r=`; ${e.segment}${void 0!==e.version?` (${e.version})`:""}`;return-1===t.value.indexOf(r)&&(t.value=`${t.value}${r}`),t}};return t}function deserializeSuccess(e){try{return JSON.parse(e.content)}catch(t){throw createDeserializationError(t.message,e)}}function deserializeFailure({content:e,status:t},r){let a=e;try{a=JSON.parse(e).message}catch(e){}return createApiError(a,t,r)}function serializeUrl(e,t,r){const a=serializeQueryParameters(r);let s=`${e.protocol}://${e.url}/${"/"===t.charAt(0)?t.substr(1):t}`;return a.length&&(s+=`?${a}`),s}function serializeQueryParameters(e){return Object.keys(e).map((t=>{return encode("%s=%s",t,(r=e[t],"[object Object]"===Object.prototype.toString.call(r)||"[object Array]"===Object.prototype.toString.call(r)?JSON.stringify(e[t]):e[t]));var r})).join("&")}function serializeData(e,t){if(e.method===MethodEnum.Get||void 0===e.data&&void 0===t.data)return;const r=Array.isArray(e.data)?e.data:{...e.data,...t.data};return JSON.stringify(r)}function serializeHeaders(e,t){const r={...e.headers,...t.headers},a={};return Object.keys(r).forEach((e=>{const t=r[e];a[e.toLowerCase()]=t})),a}function stackTraceWithoutCredentials(e){return e.map((e=>stackFrameWithoutCredentials(e)))}function stackFrameWithoutCredentials(e){const t=e.request.headers["x-algolia-api-key"]?{"x-algolia-api-key":"*****"}:{};return{...e,request:{...e.request,headers:{...e.request.headers,...t}}}}function createApiError(e,t,r){return{name:"ApiError",message:e,status:t,transporterStackTrace:r}}function createDeserializationError(e,t){return{name:"DeserializationError",message:e,response:t}}function createRetryError(e){return{name:"RetryError",message:"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",transporterStackTrace:e}}const createAnalyticsClient=e=>{const t=e.region||"us",r=createAuth(AuthMode.WithinHeaders,e.appId,e.apiKey),a=createTransporter({hosts:[{url:`analytics.${t}.algolia.com`}],...e,headers:{...r.headers(),"content-type":"application/json",...e.headers},queryParameters:{...r.queryParameters(),...e.queryParameters}});return addMethods({appId:e.appId,transporter:a},e.methods)},addABTest=e=>(t,r)=>e.transporter.write({method:MethodEnum.Post,path:"2/abtests",data:t},r),deleteABTest=e=>(t,r)=>e.transporter.write({method:MethodEnum.Delete,path:encode("2/abtests/%s",t)},r),getABTest=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("2/abtests/%s",t)},r),getABTests=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"2/abtests"},t),stopABTest=e=>(t,r)=>e.transporter.write({method:MethodEnum.Post,path:encode("2/abtests/%s/stop",t)},r),createPersonalizationClient=e=>{const t=e.region||"us",r=createAuth(AuthMode.WithinHeaders,e.appId,e.apiKey),a=createTransporter({hosts:[{url:`personalization.${t}.algolia.com`}],...e,headers:{...r.headers(),"content-type":"application/json",...e.headers},queryParameters:{...r.queryParameters(),...e.queryParameters}});return addMethods({appId:e.appId,transporter:a},e.methods)},getPersonalizationStrategy=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/strategies/personalization"},t),setPersonalizationStrategy=e=>(t,r)=>e.transporter.write({method:MethodEnum.Post,path:"1/strategies/personalization",data:t},r);function createBrowsablePromise(e){const t=r=>e.request(r).then((a=>{if(void 0!==e.batch&&e.batch(a.hits),!e.shouldStop(a))return a.cursor?t({cursor:a.cursor}):t({page:(r.page||0)+1})}));return t({})}const createSearchClient=e=>{const t=e.appId,r=createAuth(void 0!==e.authMode?e.authMode:AuthMode.WithinHeaders,t,e.apiKey),a=createTransporter({hosts:[{url:`${t}-dsn.algolia.net`,accept:CallEnum.Read},{url:`${t}.algolia.net`,accept:CallEnum.Write}].concat(shuffle([{url:`${t}-1.algolianet.com`},{url:`${t}-2.algolianet.com`},{url:`${t}-3.algolianet.com`}])),...e,headers:{...r.headers(),"content-type":"application/x-www-form-urlencoded",...e.headers},queryParameters:{...r.queryParameters(),...e.queryParameters}}),s={transporter:a,appId:t,addAlgoliaAgent(e,t){a.userAgent.add({segment:e,version:t})},clearCache:()=>Promise.all([a.requestsCache.clear(),a.responsesCache.clear()]).then((()=>{}))};return addMethods(s,e.methods)};function createMissingObjectIDError(){return{name:"MissingObjectIDError",message:"All objects must have an unique objectID (like a primary key) to be valid. Algolia is also able to generate objectIDs automatically but *it's not recommended*. To do it, use the `{'autoGenerateObjectIDIfNotExist': true}` option."}}function createObjectNotFoundError(){return{name:"ObjectNotFoundError",message:"Object not found."}}const addApiKey=e=>(t,r)=>{const{queryParameters:a,...s}=r||{},o={acl:t,...void 0!==a?{queryParameters:a}:{}};return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:"1/keys",data:o},s),((t,r)=>createRetryablePromise((a=>getApiKey(e)(t.key,r).catch((e=>{if(404!==e.status)throw e;return a()}))))))},assignUserID=e=>(t,r,a)=>{const s=createMappedRequestOptions(a);return s.queryParameters["X-Algolia-User-ID"]=t,e.transporter.write({method:MethodEnum.Post,path:"1/clusters/mapping",data:{cluster:r}},s)},assignUserIDs=e=>(t,r,a)=>e.transporter.write({method:MethodEnum.Post,path:"1/clusters/mapping/batch",data:{users:t,cluster:r}},a),clearDictionaryEntries=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("/1/dictionaries/%s/batch",t),data:{clearExistingDictionaryEntries:!0,requests:{action:"addEntry",body:[]}}},r),((t,r)=>waitAppTask(e)(t.taskID,r))),copyIndex=e=>(t,r,a)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:"copy",destination:r}},a),((r,a)=>initIndex(e)(t,{methods:{waitTask}}).waitTask(r.taskID,a))),copyRules=e=>(t,r,a)=>copyIndex(e)(t,r,{...a,scope:[ScopeEnum.Rules]}),copySettings=e=>(t,r,a)=>copyIndex(e)(t,r,{...a,scope:[ScopeEnum.Settings]}),copySynonyms=e=>(t,r,a)=>copyIndex(e)(t,r,{...a,scope:[ScopeEnum.Synonyms]}),customRequest=e=>(t,r)=>t.method===MethodEnum.Get?e.transporter.read(t,r):e.transporter.write(t,r),deleteApiKey=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/keys/%s",t)},r),((r,a)=>createRetryablePromise((r=>getApiKey(e)(t,a).then(r).catch((e=>{if(404!==e.status)throw e})))))),deleteDictionaryEntries=e=>(t,r,a)=>{const s=r.map((e=>({action:"deleteEntry",body:{objectID:e}})));return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("/1/dictionaries/%s/batch",t),data:{clearExistingDictionaryEntries:!1,requests:s}},a),((t,r)=>waitAppTask(e)(t.taskID,r)))},getApiKey=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/keys/%s",t)},r),getAppTask=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/task/%s",t.toString())},r),getDictionarySettings=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"/1/dictionaries/*/settings"},t),getLogs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/logs"},t),getTopUserIDs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters/mapping/top"},t),getUserID=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/clusters/mapping/%s",t)},r),hasPendingMappings=e=>t=>{const{retrieveMappings:r,...a}=t||{};return!0===r&&(a.getClusters=!0),e.transporter.read({method:MethodEnum.Get,path:"1/clusters/mapping/pending"},a)},initIndex=e=>(t,r={})=>addMethods({transporter:e.transporter,appId:e.appId,indexName:t},r.methods),listApiKeys=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/keys"},t),listClusters=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters"},t),listIndices=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/indexes"},t),listUserIDs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters/mapping"},t),moveIndex=e=>(t,r,a)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:"move",destination:r}},a),((r,a)=>initIndex(e)(t,{methods:{waitTask}}).waitTask(r.taskID,a))),multipleBatch=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:"1/indexes/*/batch",data:{requests:t}},r),((t,r)=>Promise.all(Object.keys(t.taskID).map((a=>initIndex(e)(a,{methods:{waitTask}}).waitTask(t.taskID[a],r)))))),multipleGetObjects=e=>(t,r)=>e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:t}},r),multipleQueries=e=>(t,r)=>{const a=t.map((e=>({...e,params:serializeQueryParameters(e.params||{})})));return e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/queries",data:{requests:a},cacheable:!0},r)},multipleSearchForFacetValues=e=>(t,r)=>Promise.all(t.map((t=>{const{facetName:a,facetQuery:s,...o}=t.params;return initIndex(e)(t.indexName,{methods:{searchForFacetValues}}).searchForFacetValues(a,s,{...r,...o})}))),removeUserID=e=>(t,r)=>{const a=createMappedRequestOptions(r);return a.queryParameters["X-Algolia-User-ID"]=t,e.transporter.write({method:MethodEnum.Delete,path:"1/clusters/mapping"},a)},replaceDictionaryEntries=e=>(t,r,a)=>{const s=r.map((e=>({action:"addEntry",body:e})));return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("/1/dictionaries/%s/batch",t),data:{clearExistingDictionaryEntries:!0,requests:s}},a),((t,r)=>waitAppTask(e)(t.taskID,r)))},restoreApiKey=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/keys/%s/restore",t)},r),((r,a)=>createRetryablePromise((r=>getApiKey(e)(t,a).catch((e=>{if(404!==e.status)throw e;return r()})))))),saveDictionaryEntries=e=>(t,r,a)=>{const s=r.map((e=>({action:"addEntry",body:e})));return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("/1/dictionaries/%s/batch",t),data:{clearExistingDictionaryEntries:!1,requests:s}},a),((t,r)=>waitAppTask(e)(t.taskID,r)))},searchDictionaryEntries=e=>(t,r,a)=>e.transporter.read({method:MethodEnum.Post,path:encode("/1/dictionaries/%s/search",t),data:{query:r},cacheable:!0},a),searchUserIDs=e=>(t,r)=>e.transporter.read({method:MethodEnum.Post,path:"1/clusters/mapping/search",data:{query:t}},r),setDictionarySettings=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Put,path:"/1/dictionaries/*/settings",data:t},r),((t,r)=>waitAppTask(e)(t.taskID,r))),updateApiKey=e=>(t,r)=>{const a=Object.assign({},r),{queryParameters:s,...o}=r||{},n=s?{queryParameters:s}:{},i=["acl","indexes","referers","restrictSources","queryParameters","description","maxQueriesPerIPPerHour","maxHitsPerQuery"];return createWaitablePromise(e.transporter.write({method:MethodEnum.Put,path:encode("1/keys/%s",t),data:n},o),((r,s)=>createRetryablePromise((r=>getApiKey(e)(t,s).then((e=>(e=>Object.keys(a).filter((e=>-1!==i.indexOf(e))).every((t=>{if(Array.isArray(e[t])&&Array.isArray(a[t])){const r=e[t];return r.length===a[t].length&&r.every(((e,r)=>e===a[t][r]))}return e[t]===a[t]})))(e)?Promise.resolve():r()))))))},waitAppTask=e=>(t,r)=>createRetryablePromise((a=>getAppTask(e)(t,r).then((e=>"published"!==e.status?a():void 0)))),batch=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/batch",e.indexName),data:{requests:t}},r),((t,r)=>waitTask(e)(t.taskID,r))),browseObjects=e=>t=>createBrowsablePromise({shouldStop:e=>void 0===e.cursor,...t,request:r=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/browse",e.indexName),data:r},t)}),browseRules=e=>t=>{const r={hitsPerPage:1e3,...t};return createBrowsablePromise({shouldStop:e=>e.hits.length<r.hitsPerPage,...r,request:t=>searchRules(e)("",{...r,...t}).then((e=>({...e,hits:e.hits.map((e=>(delete e._highlightResult,e)))})))})},browseSynonyms=e=>t=>{const r={hitsPerPage:1e3,...t};return createBrowsablePromise({shouldStop:e=>e.hits.length<r.hitsPerPage,...r,request:t=>searchSynonyms(e)("",{...r,...t}).then((e=>({...e,hits:e.hits.map((e=>(delete e._highlightResult,e)))})))})},chunkedBatch=e=>(t,r,a)=>{const{batchSize:s,...o}=a||{},n={taskIDs:[],objectIDs:[]},i=(a=0)=>{const c=[];let d;for(d=a;d<t.length&&(c.push(t[d]),c.length!==(s||1e3));d++);return 0===c.length?Promise.resolve(n):batch(e)(c.map((e=>({action:r,body:e}))),o).then((e=>(n.objectIDs=n.objectIDs.concat(e.objectIDs),n.taskIDs.push(e.taskID),d++,i(d))))};return createWaitablePromise(i(),((t,r)=>Promise.all(t.taskIDs.map((t=>waitTask(e)(t,r))))))},clearObjects=e=>t=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/clear",e.indexName)},t),((t,r)=>waitTask(e)(t.taskID,r))),clearRules=e=>t=>{const{forwardToReplicas:r,...a}=t||{},s=createMappedRequestOptions(a);return r&&(s.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/clear",e.indexName)},s),((t,r)=>waitTask(e)(t.taskID,r)))},clearSynonyms=e=>t=>{const{forwardToReplicas:r,...a}=t||{},s=createMappedRequestOptions(a);return r&&(s.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/clear",e.indexName)},s),((t,r)=>waitTask(e)(t.taskID,r)))},deleteBy=e=>(t,r)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/deleteByQuery",e.indexName),data:t},r),((t,r)=>waitTask(e)(t.taskID,r))),deleteIndex=e=>t=>createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s",e.indexName)},t),((t,r)=>waitTask(e)(t.taskID,r))),deleteObject=e=>(t,r)=>createWaitablePromise(deleteObjects(e)([t],r).then((e=>({taskID:e.taskIDs[0]}))),((t,r)=>waitTask(e)(t.taskID,r))),deleteObjects=e=>(t,r)=>{const a=t.map((e=>({objectID:e})));return chunkedBatch(e)(a,BatchActionEnum.DeleteObject,r)},deleteRule=e=>(t,r)=>{const{forwardToReplicas:a,...s}=r||{},o=createMappedRequestOptions(s);return a&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s/rules/%s",e.indexName,t)},o),((t,r)=>waitTask(e)(t.taskID,r)))},deleteSynonym=e=>(t,r)=>{const{forwardToReplicas:a,...s}=r||{},o=createMappedRequestOptions(s);return a&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s/synonyms/%s",e.indexName,t)},o),((t,r)=>waitTask(e)(t.taskID,r)))},exists=e=>t=>getSettings(e)(t).then((()=>!0)).catch((e=>{if(404!==e.status)throw e;return!1})),findAnswers=e=>(t,r,a)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/answers/%s/prediction",e.indexName),data:{query:t,queryLanguages:r},cacheable:!0},a),findObject=e=>(t,r)=>{const{query:a,paginate:s,...o}=r||{};let n=0;const i=()=>search(e)(a||"",{...o,page:n}).then((e=>{for(const[r,a]of Object.entries(e.hits))if(t(a))return{object:a,position:parseInt(r,10),page:n};if(n++,!1===s||n>=e.nbPages)throw createObjectNotFoundError();return i()}));return i()},getObject=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/%s",e.indexName,t)},r),getObjectPosition=()=>(e,t)=>{for(const[r,a]of Object.entries(e.hits))if(a.objectID===t)return parseInt(r,10);return-1},getObjects=e=>(t,r)=>{const{attributesToRetrieve:a,...s}=r||{},o=t.map((t=>({indexName:e.indexName,objectID:t,...a?{attributesToRetrieve:a}:{}})));return e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:o}},s)},getRule=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/rules/%s",e.indexName,t)},r),getSettings=e=>t=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/settings",e.indexName),data:{getVersion:2}},t),getSynonym=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/synonyms/%s",e.indexName,t)},r),getTask=e=>(t,r)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/task/%s",e.indexName,t.toString())},r),partialUpdateObject=e=>(t,r)=>createWaitablePromise(partialUpdateObjects(e)([t],r).then((e=>({objectID:e.objectIDs[0],taskID:e.taskIDs[0]}))),((t,r)=>waitTask(e)(t.taskID,r))),partialUpdateObjects=e=>(t,r)=>{const{createIfNotExists:a,...s}=r||{},o=a?BatchActionEnum.PartialUpdateObject:BatchActionEnum.PartialUpdateObjectNoCreate;return chunkedBatch(e)(t,o,s)},replaceAllObjects=e=>(t,r)=>{const{safe:a,autoGenerateObjectIDIfNotExist:s,batchSize:o,...n}=r||{},i=(t,r,a,s)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:a,destination:r}},s),((t,r)=>waitTask(e)(t.taskID,r))),c=Math.random().toString(36).substring(7),d=`${e.indexName}_tmp_${c}`,l=saveObjects({appId:e.appId,transporter:e.transporter,indexName:d});let u=[];const m=i(e.indexName,d,"copy",{...n,scope:["settings","synonyms","rules"]});return u.push(m),createWaitablePromise((a?m.wait(n):m).then((()=>{const e=l(t,{...n,autoGenerateObjectIDIfNotExist:s,batchSize:o});return u.push(e),a?e.wait(n):e})).then((()=>{const t=i(d,e.indexName,"move",n);return u.push(t),a?t.wait(n):t})).then((()=>Promise.all(u))).then((([e,t,r])=>({objectIDs:t.objectIDs,taskIDs:[e.taskID,...t.taskIDs,r.taskID]}))),((e,t)=>Promise.all(u.map((e=>e.wait(t))))))},replaceAllRules=e=>(t,r)=>saveRules(e)(t,{...r,clearExistingRules:!0}),replaceAllSynonyms=e=>(t,r)=>saveSynonyms(e)(t,{...r,clearExistingSynonyms:!0}),saveObject=e=>(t,r)=>createWaitablePromise(saveObjects(e)([t],r).then((e=>({objectID:e.objectIDs[0],taskID:e.taskIDs[0]}))),((t,r)=>waitTask(e)(t.taskID,r))),saveObjects=e=>(t,r)=>{const{autoGenerateObjectIDIfNotExist:a,...s}=r||{},o=a?BatchActionEnum.AddObject:BatchActionEnum.UpdateObject;if(o===BatchActionEnum.UpdateObject)for(const e of t)if(void 0===e.objectID)return createWaitablePromise(Promise.reject(createMissingObjectIDError()));return chunkedBatch(e)(t,o,s)},saveRule=e=>(t,r)=>saveRules(e)([t],r),saveRules=e=>(t,r)=>{const{forwardToReplicas:a,clearExistingRules:s,...o}=r||{},n=createMappedRequestOptions(o);return a&&(n.queryParameters.forwardToReplicas=1),s&&(n.queryParameters.clearExistingRules=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/batch",e.indexName),data:t},n),((t,r)=>waitTask(e)(t.taskID,r)))},saveSynonym=e=>(t,r)=>saveSynonyms(e)([t],r),saveSynonyms=e=>(t,r)=>{const{forwardToReplicas:a,clearExistingSynonyms:s,replaceExistingSynonyms:o,...n}=r||{},i=createMappedRequestOptions(n);return a&&(i.queryParameters.forwardToReplicas=1),(o||s)&&(i.queryParameters.replaceExistingSynonyms=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/batch",e.indexName),data:t},i),((t,r)=>waitTask(e)(t.taskID,r)))},search=e=>(t,r)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/query",e.indexName),data:{query:t},cacheable:!0},r),searchForFacetValues=e=>(t,r,a)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/facets/%s/query",e.indexName,t),data:{facetQuery:r},cacheable:!0},a),searchRules=e=>(t,r)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/search",e.indexName),data:{query:t}},r),searchSynonyms=e=>(t,r)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/search",e.indexName),data:{query:t}},r),setSettings=e=>(t,r)=>{const{forwardToReplicas:a,...s}=r||{},o=createMappedRequestOptions(s);return a&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Put,path:encode("1/indexes/%s/settings",e.indexName),data:t},o),((t,r)=>waitTask(e)(t.taskID,r)))},waitTask=e=>(t,r)=>createRetryablePromise((a=>getTask(e)(t,r).then((e=>"published"!==e.status?a():void 0)))),BatchActionEnum={AddObject:"addObject",UpdateObject:"updateObject",PartialUpdateObject:"partialUpdateObject",PartialUpdateObjectNoCreate:"partialUpdateObjectNoCreate",DeleteObject:"deleteObject",DeleteIndex:"delete",ClearIndex:"clear"},ScopeEnum={Settings:"settings",Synonyms:"synonyms",Rules:"rules"},LogLevelEnum={Debug:1,Info:2,Error:3};function createConsoleLogger(e){return{debug:(t,r)=>(LogLevelEnum.Debug>=e&&console.debug(t,r),Promise.resolve()),info:(t,r)=>(LogLevelEnum.Info>=e&&console.info(t,r),Promise.resolve()),error:(e,t)=>(console.error(e,t),Promise.resolve())}}function createBrowserXhrRequester(){return{send:e=>new Promise((t=>{const r=new XMLHttpRequest;r.open(e.method,e.url,!0),Object.keys(e.headers).forEach((t=>r.setRequestHeader(t,e.headers[t])));const a=(e,a)=>setTimeout((()=>{r.abort(),t({status:0,content:a,isTimedOut:!0})}),1e3*e),s=a(e.connectTimeout,"Connection timeout");let o;r.onreadystatechange=()=>{r.readyState>r.OPENED&&void 0===o&&(clearTimeout(s),o=a(e.responseTimeout,"Socket timeout"))},r.onerror=()=>{0===r.status&&(clearTimeout(s),clearTimeout(o),t({content:r.responseText||"Network request failed",status:r.status,isTimedOut:!1}))},r.onload=()=>{clearTimeout(s),clearTimeout(o),t({content:r.responseText,status:r.status,isTimedOut:!1})},r.send(e.data)}))}}function algoliasearch(e,t,r){const a={appId:e,apiKey:t,timeouts:{connect:1,read:2,write:30},requester:createBrowserXhrRequester(),logger:createConsoleLogger(LogLevelEnum.Error),responsesCache:createInMemoryCache(),requestsCache:createInMemoryCache({serializable:!1}),hostsCache:createFallbackableCache({caches:[createBrowserLocalStorageCache({key:`${version}-${e}`}),createInMemoryCache()]}),userAgent:createUserAgent(version).add({segment:"Browser"})},s={...a,...r},o=()=>e=>createPersonalizationClient({...a,...e,methods:{getPersonalizationStrategy,setPersonalizationStrategy}});return createSearchClient({...s,methods:{search:multipleQueries,searchForFacetValues:multipleSearchForFacetValues,multipleBatch,multipleGetObjects,multipleQueries,copyIndex,copySettings,copySynonyms,copyRules,moveIndex,listIndices,getLogs,listClusters,multipleSearchForFacetValues,getApiKey,addApiKey,listApiKeys,updateApiKey,deleteApiKey,restoreApiKey,assignUserID,assignUserIDs,getUserID,searchUserIDs,listUserIDs,getTopUserIDs,removeUserID,hasPendingMappings,clearDictionaryEntries,deleteDictionaryEntries,getDictionarySettings,getAppTask,replaceDictionaryEntries,saveDictionaryEntries,searchDictionaryEntries,setDictionarySettings,waitAppTask,customRequest,initIndex:e=>t=>initIndex(e)(t,{methods:{batch,delete:deleteIndex,findAnswers,getObject,getObjects,saveObject,saveObjects,search,searchForFacetValues,waitTask,setSettings,getSettings,partialUpdateObject,partialUpdateObjects,deleteObject,deleteObjects,deleteBy,clearObjects,browseObjects,getObjectPosition,findObject,exists,saveSynonym,saveSynonyms,getSynonym,searchSynonyms,browseSynonyms,deleteSynonym,clearSynonyms,replaceAllObjects,replaceAllSynonyms,searchRules,getRule,deleteRule,saveRule,saveRules,replaceAllRules,browseRules,clearRules}}),initAnalytics:()=>e=>createAnalyticsClient({...a,...e,methods:{addABTest,getABTest,getABTests,stopABTest,deleteABTest}}),initPersonalization:o,initRecommendation:()=>e=>(s.logger.info("The `initRecommendation` method is deprecated. Use `initPersonalization` instead."),o()(e))}})}algoliasearch.version=version;export default algoliasearch;